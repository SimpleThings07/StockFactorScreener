# encoding: utf-8

# Copyright (c) Ivan Antunović (ivantun05@gmail.com) - All rights reserved.
# Unintended redistribution can be punishable by law.
# By reading this message, you are automatically consenting to it
# and you are accepting that the financial data might be incorrect.
# The financial data generated by this script is for informational purposes only
# and should not be considered as investment advice.
# Use at your own risk.


# Standard Python Modules
import datetime
import os
import json
import logging
import logging.config
from dataclasses import dataclass    # Data Class
from concurrent.futures import ThreadPoolExecutor, as_completed
import math

# Time and Date Modules
import time
from datetime import datetime        # Manipulating dates and times

# Data Manipulation Modules
import pandas as pd

# MS Excel Moduels
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows

# Finance Metrics Modules
import yfinance as yf                # CHANGELOG: https://github.com/ranaroussi/yfinance/blob/main/CHANGELOG.rst

# Local Modules
from QualityMetrics import ProfitabilityMetrics, GrowthMetrics, SafetyMetrics
from ValueMetrics import (
    ValueMetrics,
    calc_ebit_to_tev,
    get_market_cap

)
from Stock import Stock
import ProfitabilityCalculator as profitabilityCalc
from ProfitabilityCalculator import (
    ROE,
    ROA
)
from StockDataTemplate import STOCK_DATA_TEMPLATE, INVALID_TICKER_TEMPLATE
from ZScoreCalculator import (
    calc_value_z_scores,
    calc_profitability_z_scores,
    calc_growth_z_scores,
)

import MetricSelector as metricSelector

from EarningsEngine import (
    calc_evar,
    calc_earnings_growth,
    get_earnings,
    NetIncomeCalcError,
    EPSCalcError,
    EarningsGrowthCalcError,
    Earnings
)


# ---------------------- Script Configuration ----------------------


# Create truly immutable Python object - values of members are immutable.
# By passing 'frozen=True' to the 'dataclass()' decorator you can emulate immutability.

@dataclass(frozen=True)
class __ProgramInfo__:
    """Class for keeping track of the Program relevant information (SW-Version, Program Description, etc)."""
    
    # MAJOR: Incremented when incompatible API changes are made. Applications and other software that use the affected APIs will break.
    #        Hence, their code have to be updated.
    majorVersion : str = "0"

    # MINOR: Incremented when new functionality is added in a backward compatible manner. It's safe to update to a new minor version
    #        without requiring code changes. Code changes are needed only to make use of the new features.
    minorVersion : str = "6"
    
    # PATCH: Incremented when backward compatible bug fixes are made. No new features are added. Some call this micro.
    patchVersion : str = "0"
    
    # Build Date of the Application - Date Format: YYMMDD
    buildDate = datetime (
        year=2025,
        month=7,
        day=13
    )

    # Complete Software Version - Major.Minor.Patch.BuildDate (yymmdd) -> e.g '1.0.0'
    swVersion: str = f"{majorVersion}.{minorVersion}.{patchVersion}"


# ---------------------- Constants ----------------------

CPU_COUNT = os.cpu_count() or 1
MAX_WORKERS = max (1, CPU_COUNT - 1)


# ---------------------- Setup logging ----------------------

SCRIPT_NAME = os.path.basename(__file__).replace('.py', '')
SCRIPT_CONFIG_FILE = "ScreenerConfig.json"
LOG_FILE = f"{SCRIPT_NAME}.log"
LOG_CONFIG_FILE = "LoggingConfig.json"


def config_logging ( ):
    """ Configure the logger

            Parameters:
                None

            Returns:
                o_log_file_path (str): Path to the current Log File

    """
    o_log_file_path = LOG_FILE


    # Load Logging configuration
    with open (LOG_CONFIG_FILE, "r", encoding='utf-8') as logging_config_file:

        logging_config = json.load(logging_config_file)

        # Update the log file name dynamically
        if 'handlers' in logging_config and 'file' in logging_config['handlers']:
            logging_config['handlers']['file']['filename'] = o_log_file_path
        else:
            raise KeyError("The logging configuration JSON is missing the 'file' handler.")

        # Takes the logging configuration from a dictionary.
        logging.config.dictConfig ( logging_config )


    # Return the currently used Log File Path
    return o_log_file_path



# ---------------------- Helper Functions ----------------------

# Output the disclaimer message at the beginning of the script run
def print_disclaimer():
    disclaimer_message = """
    Copyright (c) Ivan Antunović (ivantun05@gmail.com) - All rights reserved.
    Unintended redistribution can be punishable by law.
    By reading this message, you are automatically consenting to it 
    and you are accepting that the financial data might be incorrect.
    The financial data generated by this script is for informational purposes only 
    and should not be considered as investment advice.
    Use at your own risk.
    """
    logging.info(disclaimer_message)



# Read the configuration file
def load_config (config_file='ScreenerConfig.json'):
    try:
        with open(config_file, 'r') as f:
            config = json.load(f)
        return config
    except Exception as ex:
        logging.error(f"Error loading config file!")
        logging.exception(ex)
        return None



def is_valid_ticker (symbol: str) -> bool:
    """
    Check if a stock ticker symbol is valid by attempting to fetch its latest data.

    Parameters:
        - symbol (str): The stock ticker symbol to validate.

    Returns:
        - bool: True if the ticker is valid, False otherwise.
    """
    try:

        last_price = yf.Ticker(symbol).fast_info["last_price"]

        if last_price:
            return True
        else:
            return False

    except KeyError:          # invalid tickers raise KeyError
        return False
    except Exception:
        return False



def get_ebit_to_tev (stock, ticker):
    """
    Calculate EBIT (Earnings Before Interest and Taxes) to Total Enterprise Value (TEV) ratio.

    Formula:
        EBIT / TEV = EBIT (Operating Income) / (Market Cap + Total Debt - Cash and Cash Equivalents)

    Parameters:
        - stock (yf.Ticker): A yfinance Ticker object representing the stock.
        - ticker (str): The stock ticker symbol.
        - config (dict): A dictionary containing the configuration settings.
        - quarters (int): The number of quarters to calculate EBIT for. Default is 4.

    Returns:
        - float: EBIT/TEV ratio
    """

    ebit_to_tev_ratio, enterprise_value = None, None

    try:

        ebit_to_tev_ratio, enterprise_value = calc_ebit_to_tev ( stock, ticker )

    # Catch any general exceptions
    except Exception as ex:

        logging.error(f"Error while calculating EBIT/TEV ratio (Ticker: {ticker}): {ex}")
        # Just log the exception message without the stack trace
        # This is useful for debugging purposes, but can be removed in production code
        # If you want to log the stack trace, you can use logging.exception(ex)
        return None, None

    return ebit_to_tev_ratio, enterprise_value



def calc_profitability_growth (ticker, eps_list, gpoa_list, roe_list, roa_list, cfoa_list, gpmar_list):

    growthMetrics = None

    try:

        logging.debug(f"Calculating Compound Annual Growth Rates (CAGR) (Ticker: {ticker}).")

        # Calculate the Compound Annual Growth Rate (CAGR) for each profitability metric


        # Calculate CAGR for EPS (Earnings Per Share)
        eps_cagr = None
        try:
            eps_cagr = profitabilityCalc.calc_cagr(ticker, eps_list)
        except profitabilityCalc.CAGRCalcError as eps_cagr_error:
            logging.error(f"Error calculating CAGR for EPS (Ticker: {ticker}): {eps_cagr_error}")
            eps_cagr = None


        # Calculate CAGR for GPOA (Gross Profit over Assets)
        gpoa_cagr = None
        try:
            gpoa_cagr = profitabilityCalc.calc_cagr(ticker, gpoa_list)
        except profitabilityCalc.CAGRCalcError as gpoa_cagr_error:
            logging.error(f"Error calculating CAGR for GPOA (Ticker: {ticker}): {gpoa_cagr_error}")
            gpoa_cagr = None


        # Calculate CAGR for ROE (Return on Equity)
        roe_cagr = None
        try:
            roe_cagr = profitabilityCalc.calc_cagr(ticker, roe_list)
        except profitabilityCalc.CAGRCalcError as roe_cagr_error:
            logging.error(f"Error calculating CAGR for ROE (Ticker: {ticker}): {roe_cagr_error}")
            roe_cagr = None


        # Calculate CAGR for ROA (Return on Assets)
        roa_cagr = None
        try:
            roa_cagr = profitabilityCalc.calc_cagr(ticker, roa_list)
        except profitabilityCalc.CAGRCalcError as roa_cagr_error:
            logging.error(f"Error calculating CAGR for ROA (Ticker: {ticker}): {roa_cagr_error}")
            roa_cagr = None


        # Calculate CAGR for CFOA (Cash Flow Over Assets)
        cfoa_cagr = None
        try:
            cfoa_cagr = profitabilityCalc.calc_cagr(ticker, cfoa_list)
        except profitabilityCalc.CAGRCalcError as cfoa_cagr_error:
            logging.error(f"Error calculating CAGR for CFOA (Ticker: {ticker}): {cfoa_cagr_error}")
            cfoa_cagr = None


        # Calculate CAGR for GPMAR (Gross Profit Margin)
        gpmar_cagr = None
        try:
            gpmar_cagr = profitabilityCalc.calc_cagr(ticker, gpmar_list)
        except profitabilityCalc.CAGRCalcError as gpmar_cagr_error:
            logging.error(f"Error calculating CAGR for GPMAR (Ticker: {ticker}): {gpmar_cagr_error}")
            gpmar_cagr = None


        growthMetrics = GrowthMetrics (
            eps_cagr,
            gpoa_cagr,
            roe_cagr,
            roa_cagr,
            cfoa_cagr,
            gpmar_cagr
        )

    except Exception as exc:
        logging.error(f"Error calculating profitability growth metrics for {ticker}: {exc}")
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            logging.exception(exc)
        growthMetrics = None

    return growthMetrics



# Function to generate excel file name
def generate_file_name (config):

    # Save the file to the 'gen' directory
    # If the directory does not exist, create it
    # The file name shall be using relative path,
    # relative to the Script's directory

    GEN_DIR_NAME = "gen"

    # Check if the 'gen' directory exists (relative to the Script's directory)
    if not os.path.exists(GEN_DIR_NAME):
        os.makedirs(GEN_DIR_NAME)

    # Get the base name of the file from the configuration
    FILE_BASE_NAME = config['Output_Excel_Filename']

    # Get the current date

    # Get the current date
    date_str = datetime.now().strftime("%Y-%m-%d")

    # Generate the final file name using the gen directory, and the date
    file_name_final = f"{GEN_DIR_NAME}\\{date_str}_{FILE_BASE_NAME}.xlsx"

    # Check if the file already exists, and increment the filename if it does
    file_counter = 1
    while os.path.exists(file_name_final):
        file_name_final = f"{GEN_DIR_NAME}\\{date_str}_{FILE_BASE_NAME}_{file_counter}.xlsx"
        file_counter += 1

    return file_name_final



# Function to save data to excel file
def save_to_excel (stock_data, stock_factor_metrics_list, tickers_and_weights, config):

    # Generate the file name with today's date
    file_name = generate_file_name (config)

    # Reorder stock_data to match tickers_and_weights
    ordered_stock_data = {}
    for ticker_data in tickers_and_weights:
        ticker_current = ticker_data["ticker"] if isinstance(ticker_data, dict) else ticker_data[0]
        if ticker_current in stock_data:

            # Find the corresponding Stock object
            stock_obj = next((stock for stock in stock_factor_metrics_list if stock.ticker == ticker_current), None)
            if stock_obj and stock_obj.value_z_score_result:
                composite_score = stock_obj.value_z_score_result.composite
            else:
                composite_score = "N/A"
            # Add composite score to the output dictionary
            stock_data[ticker_current]["Value Composite Z-Score"] = (
                '{:,.2f}'.format(composite_score) if composite_score is not None and not isinstance(composite_score, str) and not math.isnan(composite_score) else "N/A"
            )

            # Add the stock object to the stock_data dictionary
            ordered_stock_data[ticker_current] = stock_data[ticker_current]

    # Convert the data to a pandas DataFrame
    df = pd.DataFrame.from_dict(ordered_stock_data, orient='index')

    # Prepare the workbook
    wb = Workbook()
    worksheet = wb.active
    if worksheet is None:
        worksheet = wb.create_sheet(title="Sheet1")

    # Insert the ETF and Total Investment headers at the top
    worksheet['A1'] = "ETF"
    worksheet['B1'] = "MSCI World Momentum Index"
    worksheet['A2'] = "Total Investment"
    worksheet['B2'] = "1.000,00 €"

    # Add hyperlink to "S&P SmallCap Quality"
    worksheet['B1'].hyperlink = "https://www.ishares.com/uk/individual/en/products/270051/ishares-msci-world-momentum-factor-ucits-etf?switchLocale=y&siteEntryPassthrough=true"

    # Set column widths for better formatting
    worksheet.column_dimensions['A'].width = 20
    worksheet.column_dimensions['B'].width = 30

    # Append the DataFrame to the Excel worksheet
    for r_idx, row in enumerate(dataframe_to_rows(df, index=True, header=True), 4):
        worksheet.append(row)

    # Save the data to the Excel file
    df.to_excel(file_name)

    # Show the first few rows of the DataFrame
    df.head()



def calc_value_metrics (stock, ticker):

        # -------------- P/E Ratio --------------

        # fetch Forward P/E ratio
        forwardPE = stock.info.get("forwardPE", None)
        forwardPE_rnd = round(forwardPE, 2) if forwardPE is not None else "N/A"
        logging.info(f"P/E (Forward) (Ticker: {ticker}): {forwardPE_rnd}")

        # fetch Trailing P/E ratio
        trailingPE = stock.info.get("trailingPE", None)
        trailingPE_rnd = "N/A" if trailingPE in (None, 'Infinity') else round(float(trailingPE), 2)

        logging.info(f"P/E (Trailing) (Ticker: {ticker}): {trailingPE_rnd}")


        # -------------- EBIT/TEV Ratio --------------

        ebit_to_tev, enterprise_value = get_ebit_to_tev (stock, ticker)
        ebit_to_tev_perc = round(ebit_to_tev * 100, 2) if ebit_to_tev is not None else None
        if ebit_to_tev_perc is not None:
            logging.info(f"EBIT/TEV (Ticker: {ticker}): {ebit_to_tev_perc} %")
        else:
            logging.info(f"EBIT/TEV (Ticker: {ticker}): N/A")

        # -------------- P/B Ratio --------------

        # fetch P/B ratio
        pb_ratio = stock.info.get("priceToBook", None)
        pb_ratio_rnd = round(pb_ratio, 2) if pb_ratio is not None else None
        logging.info(f"P/B (Ticker: {ticker}): {pb_ratio_rnd}")

        # -------------- Value Metrics Data --------------

        value_metrics = ValueMetrics (
            ticker,
            trailingPE,
            forwardPE,
            ebit_to_tev,                # EBIT/TEV ratio
            enterprise_value,            # Total Enterprise Value (TEV)
            pb_ratio                    # P/B ratio
        )

        return value_metrics



def calc_earnings_metrics (stock, ticker, config):

    # -------------- 1. Get Earnings (EPS) Data --------------
    earnings_data = None

    eps_list, eps_growth_list = None, None
    try:

        # 1.1 Get EPS data
        eps_list = get_earnings (
            stock,
            ticker,
            "eps",
            config['Earnings_Period'],
            config['AlphaVantage']['API_Key'],
            config['AlphaVantage']['Base_URL'],
        )

        eps_latest_rnd = round (eps_list[0], 2) if eps_list is not None else None
        if eps_list:
            logging.info(f"Fetched Earnings data (EPS) for {len(eps_list)} years period (Ticker: {ticker}).")
            logging.info(f"EPS (latest) (Ticker: {ticker}): {(eps_latest_rnd)}")

        # 1.2 Calculate EPS Growth Year-on-Year (YoY) for each year
        eps_growth_list = calc_earnings_growth (
            ticker,
            eps_list
        )

    except Exception as e:
        logging.error(f"Error fetching Earnings (EPS) for {ticker}: {e}")
        eps_list = None
        eps_growth_list = None


    # -------------- 2. Get Earnings (Net Income) Data --------------

    net_income_list, net_income_growth_list = None, None
    try:
        # 2.1 Get Net Income data
        net_income_list = profitabilityCalc.get_earnings (
            stock,
            ticker,
            "net_income",
            config['Earnings_Period'],
            config['AlphaVantage']['API_Key'],
            config['AlphaVantage']['Base_URL'],
        )

        if net_income_list:
            logging.info(f"Fetched Earnings data (Net Income) for {len(net_income_list)} years period (Ticker: {ticker}).")

        # 2.2 Calculate Net Income Growth Year-on-Year (YoY) for each year
        net_income_growth_list = calc_earnings_growth (
            ticker,
            net_income_list
        )

    except Exception as e:
        logging.error(f"Error fetching Earnings (Net Income) for {ticker}: {e}")
        net_income_list = None
        net_income_growth_list = None

    # -------------- Calculate Earnings Variability (EVAR) --------------

    # Calculate Earnings Variability Earnings Variability is defined as
    # the standard deviation of y-o-y earnings per share growth over the last five fiscal years.
    # The lower the EVAR, the better. A lower EVAR indicates that the company has more stable earnings growth.

    eps_evar, eps_evar_perc = None, None
    try:

        if eps_growth_list:
            logging.info(f"Calculating Earnings Variability (EVAR) using EPS over {len(eps_growth_list)} year period (Ticker: {ticker}).")
            # Calculate EVAR using EPS
            eps_evar = calc_evar (ticker, eps_growth_list)
            eps_evar_perc = round (eps_evar * 100, 2) if eps_evar is not None else "N/A"

            if eps_list is not None:
                logging.info(f"EVAR {len(eps_list)}Y (EPS) (Ticker: {ticker}): {(eps_evar_perc)} %")
            else:
                logging.info(f"EVAR (EPS) (Ticker: {ticker}): N/A")

        else:
            logging.error(f"Cannot calculate EVAR (EPS) for {ticker}. No Earnings Growth data available.")
            eps_evar = None
            eps_evar_perc = None

    except Exception as evar_error:
        logging.error(f"Error calculating EVAR (Ticker: {ticker}): {evar_error}")
        eps_evar = None
        eps_evar_perc = None

    net_income_evar, net_income_evar_perc = None, None
    try:
        if net_income_growth_list:
            logging.info(f"Calculating Earnings Variability (EVAR) using Net Income over {len(net_income_growth_list)} year period (Ticker: {ticker}).")
            # Calculate EVAR using Net Income
            net_income_evar = calc_evar (ticker, net_income_growth_list)
            net_income_evar_perc = round (net_income_evar * 100, 2) if net_income_evar is not None else "N/A"
            if net_income_list is not None:
                logging.info(f"EVAR {len(net_income_list)}Y (Net Income) (Ticker: {ticker}): {(net_income_evar_perc)} %")
            else:
                logging.info(f"EVAR (Net Income) (Ticker: {ticker}): N/A")

        else:
            logging.error (f"Cannot calculate EVAR (Net Income) for {ticker}. No Earnings Growth data available.")
            net_income_evar = None
            net_income_evar_perc = None

    except Exception as evar_error:
        logging.error (f"Error calculating EVAR (Ticker: {ticker}): {evar_error}")
        net_income_evar = None
        net_income_evar_perc = None

    # -------------- Compound Annual Growth Rate (CAGR) --------------

    eps_cagr = None
    try:

        eps_cagr = profitabilityCalc.calc_cagr (ticker, eps_list)
        eps_cagr_perc = round(eps_cagr * 100, 2) if eps_cagr is not None else None
        if eps_cagr_perc is not None:
            logging.info (f"CAGR {len(eps_list)}Y (EPS) (Ticker: {ticker}): {eps_cagr_perc} %")
        else:
            logging.info (f"CAGR (EPS) (Ticker: {ticker}): N/A")

    except Exception as cagr_error:
        logging.error (f"Error calculating CAGR (EPS) (Ticker: {ticker}): {cagr_error}")
        eps_cagr = None


    net_income_cagr = None
    try:

        net_income_cagr = profitabilityCalc.calc_cagr(ticker, net_income_list)
        net_income_cagr_perc = round(net_income_cagr * 100, 2) if net_income_cagr is not None else None
        if net_income_cagr is not None:
            logging.info (f"CAGR {len(net_income_list)}Y (Net Income) (Ticker: {ticker}): {net_income_cagr_perc} %")
        else:
            logging.info (f"CAGR (Net Income) (Ticker: {ticker}): N/A")

    except Exception as cagr_error:
        logging.error (f"Error calculating CAGR (Net Income) (Ticker: {ticker}): {cagr_error}")
        net_income_cagr = None


    # -------------- Create Earnings Data Object --------------
    # Create an Earnings object to hold all the earnings data
    # This object will contain EPS, Net Income, and their respective growth rates, EVAR, and CAGR values
    earnings_data = Earnings (
        eps_list,
        eps_growth_list,
        eps_evar,
        eps_cagr,
        net_income_list,
        net_income_growth_list,
        net_income_evar,
        net_income_cagr
    )

    return earnings_data



def analyze_stock (config, stock, ticker, weight):

    try:

        logging.info(f"---------------------- {ticker} ----------------------")

        # -------------- Company Name --------------

        # Extract the company name
        company_name = stock.info.get("longName", "N/A")
        # If the company name is not available, set it to "N/A"
        if company_name is None or company_name == "":
            company_name = "N/A"
        # Log the company name
        logging.info(f"Company: {company_name}")

        # --------------- Company Country Of Origin ---------------

        # Extract the country of origin
        country = stock.info.get("country", "N/A")
        # If the country is not available, set it to "N/A"
        if country is None or country == "":
            country = "N/A"
        # Log the country of origin
        logging.info(f"Country: {country}")


        ########################################################
        ###################   VALUE METRICS   ##################
        ########################################################

        value_metrics = calc_value_metrics (
            stock,
            ticker
        )

        ########################################################
        ###############   PROFITABILITY METRICS   ##############
        ########################################################

        earnings = calc_earnings_metrics (
            stock,
            ticker,
            config
        )

        # -------------- Dividend Yield Fetched Data --------------

        # Safe multiplication to handle None values, Convert to percentage
        dividend_yield = stock.info.get("dividendYield", None)

        if dividend_yield:
            logging.info(f"Dividend Yield (Ticker: {ticker}): {round(dividend_yield, 2)} %")
        else:
            logging.info(f"Dividend Yield (Ticker: {ticker}): N/A")

        # -------------- Return on Equity (ROE) --------------

        # TODO: TTM - Most factor datasets (e.g., AQR DS, Alpha Research Platform) choose “closest past match” so that both numerator and denominator
        # are built only from information that was public at, or before, that quarter-end.

        # Fetch ROE using Yahoo Finance data
        roe_ttm_yf = profitabilityCalc.get_roe_ttm (stock.info)
        # Convert ROE to percentage
        roe_ttm_yf_perc = roe_ttm_yf * 100 if roe_ttm_yf is not None else None
        if roe_ttm_yf_perc is not None:
            logging.info(f"ROE (ttm) (Yahoo Finance) (Ticker: {ticker}): {round(roe_ttm_yf_perc, 2)} %")
        else:
            logging.info(f"ROE (ttm) (Yahoo Finance) (Ticker: {ticker}): N/A")


        roe_list = None
        try:
            # Calculate ROE using Net Income and Shareholder's Equity
            roe_list = profitabilityCalc.calc_roe (stock, ticker, config, config.get("Earnings_Period"))

        except profitabilityCalc.ROECalcError as roe_error:
            logging.error (f"Error calculating ROE (Ticker: {ticker}): {roe_error}")
            roe_list = None

        # -------------- Return on Equity - Calculated --------------
        roe_ttm_calc, roe_calc_perc = None, None
        try:
            # Get the TTM ROE
            roe_ttm = profitabilityCalc.calc_roe_ttm ( stock, ticker )

            # Convert ROE to percentage
            roe_calc_perc = roe_ttm * 100 if roe_ttm is not None else None
            if roe_ttm_yf_perc is not None and roe_calc_perc is not None:
                logging.info("ROE - Calc (Ticker: %s): %.2f %%", ticker, round(roe_calc_perc, 2))
            else:
                logging.info("ROE - Calc (Ticker: %s): N/A", ticker)

        except profitabilityCalc.ROECalcError as roe_error:
            logging.error (f"Error calculating ROE (ttm) (Ticker: {ticker}): {roe_error}")
            roe_ttm = None

        # -------------- Return on Equity - MSCI --------------
        roe_msci = None
        try:

            roe_msci = profitabilityCalc.calc_roe_msci (stock, ticker)

            roe_msci_perc = roe_msci * 100 if roe_msci is not None else None
            if roe_msci_perc is not None:
                logging.info (f"ROE - MSCI (Ticker: {ticker}): {round(roe_msci_perc, 2)} %")
            else:
                logging.info (f"ROE - MSCI (Ticker: {ticker}): N/A")

        except Exception as roe_error:

            logging.error (f"Error calculating ROE - MSCI (Ticker: {ticker}): {roe_error}")

        roe_data = ROE (
            roe_ttm_yf,
            roe_ttm_calc,
            roe_list,
            roe_msci,
        )

        roe_selected = metricSelector.select_roe ( roe_data )




        # TODO: calc_roe function - if the net income data from yahoo finance is missing
        #       then avoid using Stockholders Equity data from yahoo finance to calcualte ROE
        #       else the ROE might be calculated with the mismatching data.
        #       For example, Net Income from 2023 and Stockholders Equity from 2022.
        #       Such mismatching data can lead to incorrect ROE calculations.

        # TODO: Calculate ROE and ROA over multiple time periods
        #       Compare the logs before and after, and validate the calculations

        # TODO: Verify that CAGR calculations are correct for all stocks using https://finchat.io/dashboard/

        # TODO: Parallize the calculations of stock finacial metrics

        # TODO Calculcate ROE using EPS

        # TODO: Check the missing Net Income data for ROE calculcation for INVX
        # TODO: Validate Standard Deviation Calucations for all stocks


        # -------------- Return on Assets (ROA) --------------

        # Fetch ROA using Yahoo Finance data
        roa_ttm_yf = profitabilityCalc.get_roa_ttm (stock.info)
        # Convert ROA to percentage
        roa_ttm_yf_perc = roa_ttm_yf * 100 if roa_ttm_yf is not None else None
        if roa_ttm_yf_perc is not None:
            logging.info(f"ROA (ttm) (Yahoo Finance) (Ticker: {ticker}): {round(roa_ttm_yf_perc, 2)} %")
        else:
            logging.info(f"ROA (ttm) (Yahoo Finance) (Ticker: {ticker}): N/A")


        # Calculate ROA TTM
        roa_ttm_calc = None
        try:
            roa_ttm_calc = profitabilityCalc.calc_roa_ttm ( stock, ticker )

            # If the ROA TTM is not None, convert it to percentage
            roa_ttm_calc_perc = roa_ttm_calc * 100 if roa_ttm_calc is not None else None
            if roa_ttm_calc_perc is not None:
                logging.info("ROA - Calc (Ticker: %s): %.2f %%", ticker, round(roa_ttm_calc_perc, 2))
            else:
                logging.info("ROA - Calc (Ticker: %s): N/A", ticker)

        except profitabilityCalc.ROACalcError as roa_error:
            logging.error(f"Error calculating ROA (ttm) (Ticker: {ticker}): {roa_error}")
            roa_ttm_calc = None


        roa_list, roa_calc_perc = None, None
        try:
            # Calculate ROA using Net Income and Total Assets
            roa_list = profitabilityCalc.calc_roa (stock, ticker, config)

            if roa_list is not None:
                # Convert ROA to percentage
                roa_calc_perc = roa_list[0] * 100 if roa_list[0] is not None else None
                if roa_calc_perc is not None:
                    logging.info("ROA - Calc (Ticker: %s): %.2f %%", ticker, round(roa_calc_perc, 2))
                else:
                    logging.info("ROA - Calc (Ticker: %s): N/A", ticker)
            else:
                logging.error(f"Cannot calculate ROA (Ticker: {ticker}): ROA list is empty")
                roa_calc_perc = None
    
        except profitabilityCalc.ROACalcError as roa_error:
            logging.error(f"Error calculating ROA (Ticker: {ticker}): {roa_error}")
            roa_list = None
            roa_calc_perc = None

        roa = ROA (
            roa_ttm_yf,
            roa_ttm_calc,
            roa_list
        )

        roa_selected = metricSelector.select_roa ( roa )


        # -------------- Cash Flow Over Assets (CFOA) --------------

        cfoa_list, cfoa_latest_perc = None, None
        try:
            cfoa_list = profitabilityCalc.calc_cfoa (stock, ticker)
            cfoa_latest_perc = round(cfoa_list[0] * 100, 2) if cfoa_list is not None else None
            logging.info(f"CFOA (annual) (Ticker: {ticker}): {cfoa_latest_perc} %")

        except profitabilityCalc.CFOACalcError as cfoa_error:
            logging.error(f"Error calculating CFOA (annual) (Ticker: {ticker}): {cfoa_error}")
            cfoa_list = None
            cfoa_latest_perc = None

        # Calculate CFOA TTM
        cfoa_ttm, cfoa_ttm_perc = None, None
        try:
            cfoa_ttm = profitabilityCalc.calc_cfoa_ttm (stock, ticker)
            cfoa_ttm_perc = round(cfoa_ttm * 100, 2) if cfoa_ttm is not None else None
            logging.info(f"CFOA (ttm) (Ticker: {ticker}): {cfoa_ttm_perc} %")

        except profitabilityCalc.CFOACalcError as cfoa_error:
            logging.error(f"Error calculating CFOA (ttm) (Ticker: {ticker}): {cfoa_error}")
            cfoa_ttm = None
            cfoa_ttm_perc = None


        cfoa_selected = metricSelector.select_cfoa (
            cfoa_ttm,
            cfoa_list
        )

        # --------------   Gross Profits Over Assets (GPOA) --------------
 
        # TODO: Check the the GPOA is not N/A for the following stocks:
        #       ECG, AX, RDN


        gpoa_list, gpoa_latest_perc = None, None
        try:
            # Calculate GPOA (Gross Profit over Assets) annual data
            gpoa_list = profitabilityCalc.calc_gpoa_annual (stock, ticker, config, config.get("Earnings_Period"))

            gpoa_latest_perc = round(gpoa_list[0] * 100, 2) if gpoa_list is not None else None
            logging.info(f"GPOA (Ticker: {ticker}): {gpoa_latest_perc} %")

        except Exception as gpoa_error:
            logging.error(f"Error calculating GPOA (Ticker: {ticker}): {gpoa_error}")
            gpoa_list = None
            gpoa_latest_perc = None


        gpoa_ttm, gpoa_ttm_perc = None, None
        try:

            # Calculate GPOA
            gpoa_ttm = profitabilityCalc.calc_gpoa_ttm ( stock, ticker )
            # Convert GPOA to percentage
            gpoa_ttm_perc = round(gpoa_ttm * 100, 2) if gpoa_ttm is not None else None

        except profitabilityCalc.GPOACalcError as gpoa_error:
            logging.error(f"Error calculating GPOA and GPMAR TTM (Ticker: {ticker}): {gpoa_error}")
            gpoa_ttm = None


        gpoa_selected = metricSelector.select_gpoa (
            gpoa_ttm,
            gpoa_list
        )


        # --------------   Gross Profit Margin (GPMAR)      --------------

        gpmar_list, gpmar_latest_perc = None, None
        try:
            # Calculate GPMAR (Gross Profit Margin) anual data
            gpmar_list = profitabilityCalc.calc_gpmar_annual (stock, ticker, config, config.get("Earnings_Period"))

            gpmar_latest_perc = round(gpmar_list[0] * 100, 2) if gpmar_list is not None else None
            logging.info(f"GPMAR (Ticker: {ticker}): {gpmar_latest_perc} %")

        except Exception as gpoa_error:
            logging.error(f"Error calculating GPOA and GPMAR (Ticker: {ticker}): {gpoa_error}")
            gpmar_list = None
            gpmar_latest_perc = None


        gpmar_ttm, gpmar_ttm_perc = None, None
        try:
            # Calculate GPMAR TTM
            gpmar_ttm =  profitabilityCalc.calc_gpmar_ttm ( stock, ticker )
            # Convert GPMAR to percentage
            gpmar_ttm_perc = round(gpmar_ttm * 100, 2) if gpmar_ttm is not None else None
        except profitabilityCalc.GPMARCalcError as gpmar_error:
            logging.error(f"Error calculating GPMAR TTM (Ticker: {ticker}): {gpmar_error}")
            gpmar_ttm = None


        gpmar_selected = metricSelector.select_gpmar (
            gpmar_ttm,
            gpmar_list
        )


        # -------------- Profit Margin --------------

        # Safe multiplication to handle None values, Convert to percentage
        profit_margin = stock.info.get("profitMargins", None)
        profit_margin_percent = profit_margin * 100 if profit_margin is not None else None
        if profit_margin_percent is not None:
            logging.info(f"Profit Margin (Ticker: {ticker}): {round(profit_margin_percent, 2)} %")
        else:
            logging.info(f"Profit Margin (Ticker: {ticker}): N/A")


        # -------------- Market Cap --------------
        # Convert Market Cap to billions
        market_cap = get_market_cap(stock)
        market_cap_bill = round(market_cap / 1e9, 2) if market_cap is not None else "N/A"  # Convert Market Cap to billions


        # -------------- Sector and Industry --------------

        # Extract the industry and sector
        sector = stock.info.get("sector", "N/A")
        industry = stock.info.get("industry", "N/A")

        logging.info(f"Sector: {sector}")
        logging.info(f"Industry: {industry}")

        # TODO: Calculate Pie Chart of Sectors diversification
        #       for the calculcated weightings using your own qualit methodology
        #       We want to be diviersified across sectors.
        #       Diversification is the only free lunch in investing.


        # TODO: Calculate all Profitability Metrics using TTM data, and not latest year data

        # -------------- Profitability Metrics --------------
        profitability_metrics = ProfitabilityMetrics (
            ticker,
            earnings,                  # Earnings data
            gpoa_selected,             # Gross Profit over Assets (GPOA)
            gpmar_selected,            # Gross Profit Margin (GPMAR)
            roe_selected,              # Return on Equity (ROE) TTM
            roa_selected,              # Return on Assets (ROA) TTM
            cfoa_selected,             # Cash Flow over Assets (CFOA) last year
            None                       # Accruals None
        )


        # --------------  Profitability Growth Metrics --------------
        # eps_growth_list
        # gpoa_growth
        # roe_growth      
        # roa_growth  
        # cfoa_growth
        # gpmar_growth
        profitability_growth_metrics = calc_profitability_growth (
            ticker,
            earnings.eps_list,            # Five-year growth in Earnings per Share (EPS) - EPS Growth
            gpoa_list,                    # Five-year growth in Gross Profits over Assets - GPOA Growth
            roe_list,                     # Five-year growth in Return on Equity - ROE Growth
            roa_list,                     # Five-year growth in Return on Assets - ROA Growth
            cfoa_list,                    # Five-year growth in Cash Flow over Assets - CFOA Growth
            gpmar_list                    # Five-year growth in Gross Profit Margin - GPMAR Growth
        )

        # -------------- Store Stock Metrics --------------

        stock_factor_metrics = Stock (
            ticker,
            sector,
            value_metrics,
            profitability_metrics,
            profitability_growth_metrics,
            None
        )

        # Build Stock Data Dictionary
        stock_data = STOCK_DATA_TEMPLATE.copy()
        stock_data.update({
            "Company": company_name,
            "Country" : country,
            "Original Weight": weight,  # Add the original weight for the company
            "Market Cap (in Billions)": round(market_cap_bill, 2),
            "P/E (Forward)": '{:,.2f}'.format(value_metrics.pe_forward) if value_metrics.pe_forward is not None else "N/A",
            "P/E (Trailing)":  '{:,.2f}'.format(value_metrics.pe_trailing) if value_metrics.pe_trailing is not None else "N/A",
            "EBIT/TEV (%)": '{:,.2f}'.format(round(value_metrics.ebit_to_tev * 100, 2)) if value_metrics.ebit_to_tev is not None else "N/A",
            "TEV (in Billions)": '{:,.2f}'.format(round(value_metrics.enterprise_value_bill, 2)) if value_metrics.enterprise_value_bill is not None else "N/A",
            "P/B": '{:,.2f}'.format( round(value_metrics.pb_ratio, 2)) if value_metrics.pb_ratio is not None else "N/A",
            "EPS (latest)": '{:,.2f}'.format( round (earnings.eps_list[0], 2) ) if earnings.eps_list is not None else "N/A",
            "EVAR - EPS (%)":"{}".format( round (earnings.eps_evar * 100, 2) ) if earnings.eps_evar is not None else "N/A",
            "EVAR - Net Income (%)":"{}".format ( round(earnings.net_income_evar * 100, 2) ) if earnings.net_income_evar is not None else "N/A",
            "CAGR - EPS (%)": '{:,.2f}'.format(round(earnings.eps_cagr * 100, 2)) if earnings.eps_cagr is not None else "N/A",
            "CAGR - Net Income (%)": '{:,.2f}'.format( round(earnings.net_income_cagr * 100, 2) ) if earnings.net_income_cagr is not None else "N/A",
            "Dividend Yield (%)": '{:,.2f}'.format(dividend_yield) if dividend_yield is not None else "N/A",     
            "ROE (ttm) - yFinance (%)": '{:,.2f}'.format(roe_ttm_yf_perc) if roe_ttm_yf_perc is not None else "N/A",
            "ROE (ttm) - Calc (%)": '{:,.2f}'.format(roe_calc_perc) if roe_calc_perc is not None else "N/A",
            "ROA - yFinance (%)": '{:,.2f}'.format(roa_ttm_yf_perc) if roa_ttm_yf_perc is not None else "N/A",
            "ROA - Calc (%)": '{:,.2f}'.format(roa_calc_perc) if roa_calc_perc is not None else "N/A",
            "CFOA (annual) (%)": '{:,.2f}'.format(cfoa_latest_perc) if cfoa_latest_perc is not None else "N/A",
            "CFOA (ttm) (%)": '{:,.2f}'.format(cfoa_ttm_perc) if cfoa_ttm_perc is not None else "N/A",
            "GPOA (ttm) (%)": '{:,.2f}'.format(gpoa_ttm_perc) if gpoa_ttm_perc is not None else "N/A",
            "GPMAR (ttm) (%)": '{:,.2f}'.format(gpmar_ttm_perc) if gpmar_ttm_perc is not None else "N/A",
            "Profit Margin (%)": '{:,.2f}'.format(profit_margin_percent) if profit_margin_percent is not None else "N/A",
            "Sector": sector,
            "Industry": industry
        })

        # Return the stock data and metrics
        return stock_data, stock_factor_metrics

    except Exception as e:
        logging.error("Unhandled error analyzing stock (Ticker: %s)", ticker)
        logging.exception(e)
        return None, None



def analyze_one_stock (ticker_data, i_config):

    # Get the ticker and weight
    ticker = ticker_data["ticker"]
    weight = ticker_data["weight"]

    try:

        # Fetch the stock data from Yahoo Finance
        stock = yf.Ticker(ticker)

        # Get stock data
        stock_info = stock.info

        # Check if the stock info is available and contains the 'symbol' key
        # and if the ticker symbol is valid
        if stock_info and 'symbol' in stock_info and is_valid_ticker(ticker):

            # If the ticker symbol is valid, analyze the stock
            stock_data_entry, stock_factor_metrics = analyze_stock (
                i_config,
                stock,
                ticker,
                weight
            )

            return ticker, stock_data_entry, stock_factor_metrics

        else:
            # If the ticker symbol is invalid, log the error and return an invalid entry
            # Log the error and return an invalid entry
            logging.error(f"Invalid Stock Ticker Symbol: {ticker}")
            logging.error(f"Skipping Stock Analysis for {ticker}.")
            invalid_entry = INVALID_TICKER_TEMPLATE.copy()
            invalid_entry["Company"] = ticker
            invalid_entry["Original Weight"] = weight

            return ticker, invalid_entry, None
        
    except Exception as e:
        # Log the error and return an invalid entry
        logging.critical(f"Error analyzing stock (Ticker: {ticker}): {e}!")
        logging.exception(e)
        invalid_entry = INVALID_TICKER_TEMPLATE.copy()
        invalid_entry["Company"] = ticker
        invalid_entry["Original Weight"] = weight

        return ticker, invalid_entry, None



# ---------------------- Main Function ----------------------

# Example usage in the script
if __name__ == "__main__":

    current_ticker = None

    try:

        # -------------------------------- 1. Initialize the Script -------------------------------- #

        # Store Script Start Date
        programStartDate = time.strftime ('%Y-%m-%d %H:%M:%S', time.localtime())

        # Store Scripts Start Time
        programStartTime = datetime.now ( )

        log_file_path = config_logging()

        # Instantiate Program Information Object
        __program__ = __ProgramInfo__ ( )

        # Print the Script Date (Format YYYY-MM-DD) and Version
        logging.info(f"Running Stock Analysis Script:\n    Version: {__program__.swVersion}\n    Date: {__program__.buildDate.strftime('%d.%m.%Y')}")

        # Print the disclaimer message
        print_disclaimer()

        # Load the configuration file
        config = load_config (SCRIPT_CONFIG_FILE)
        if not config:
            logging.error("Config file could not be loaded. Exiting script.")
            exit(-1)

        # Get the tickers and weights from the config file
        tickers_and_weights = config.get ("Tickers_and_Weights", None)

        # Fetch data using yfinance and include original weights
        stock_data = {}

        # Initialize the list of stock metrics, there metrics for each stock will be stored
        stock_factor_metrics_list = []

        # Enable Debug Mode for yfinance
        #yf.enable_debug_mode()

        # Get the yfinance logger
        yf_logger = logging.getLogger("yfinance")
        yf_logger.disabled = True
        yf_logger.propagate = False

        # Loop through the tickers and weights
        with ThreadPoolExecutor (max_workers=MAX_WORKERS) as executor:

            futures = [ executor.submit ( analyze_one_stock, ticker_data, config ) for ticker_data in tickers_and_weights ]

            for future in as_completed (futures):
                ticker, stock_data_entry, stock_factor_metrics = future.result()
                current_ticker = ticker  # Track the most recently processed ticker globally
                if stock_data_entry:
                    stock_data[ticker] = stock_data_entry
                if stock_factor_metrics:
                    stock_factor_metrics_list.append(stock_factor_metrics)

        # Step 2: Calculate Z-scores for All Stocks (Normalize after gathering data)
        #calculate_z_scores(stock_data)
        # Calculate z-score for Value Metrics

        # 1. Gather Metrics for All Stocks:
        #   - Collect the relevant metrics (Value metrics, Profitability metrics, and Growth metrics) for each stock. This happens first, and we store them in a stock_data dictionary.

        # 2. Once All Stocks Are Analyzed:
        #   - Once we’ve collected the data for all stocks, normalize the metrics by calculating Z-scores for each metric across all stocks.
        #   - Calculate Z-scores for each of the three categories (Value, Profitability, and Growth) for all the stocks at the end, ensuring they are normalized across the entire group of stocks.

        value_cfg = config.get("ValueFactor", None)
        profitability_cfg = config.get("ProfitabilityFactor", None)
        growth_cfg = config.get("GrowthFactor", None)

        # Calculate Z-scores for each factor

        ####### Value Factor Z-Scores Calculation #######

        # TODO: We might not have to return, as the function modifies the input parameter (stock list) itself ?
        value_zscore  = calc_value_z_scores (
            stock_factor_metrics_list,
            value_cfg ["z_score_metrics"]
        )
        # After Z-score calculation, update each stock's data dictionary
        for stock in stock_factor_metrics_list:
            ticker = stock.ticker
            if ticker in stock_data:
                composite_score = stock.value_z_score_result.composite if stock.value_z_score_result else None
                stock_data[ticker]["Z-Score Value"] = (
                    '{:,.2f}'.format(composite_score) if composite_score is not None and not isinstance(composite_score, str) and not math.isnan(composite_score) else "N/A"
                )

        ####### Value Factor Z-Scores Calculation #######

        # TODO: Calculate Debt to Equity Ratio for profitability metrics
        # TODO: Calculate Accruals for profitability metrics
        #profit_z = calc_profitability_z_scores (stock_factor_metrics_list, profitability_cfg)
        #growth_z = calc_growth_z_scores (stock_factor_metrics_list, growth_cfg)

        # 3. Final Z-Score Calculation:
        #   - After the Z-scores for the individual metrics are calculated, compute the final Z-score for each stock by averaging the Z-scores from all three categories.

        # 4. Output the Results:
        #   - Save the final Z-scores and all metrics in the Excel file for easy reference.


        # -------------------- Excel File Generation --------------------

        # Save the stock data to an Excel file
        save_to_excel (
            stock_data,
            stock_factor_metrics_list,
            tickers_and_weights,
            config
        )

        # -------------------- Program Runtime --------------------
        # Output program's runtime
        programRuntime = datetime.now() - programStartTime
        logging.info (f"Program total runtime: {programRuntime}")

    except Exception as e:
        logging.critical(f"Unhandled ERROR running the Script occurred (Ticker: {current_ticker}): {e} !")
        logging.exception(f"Unhandled exception occurred while running the script: {e}")
        raise e
    
    finally:
        logging.shutdown()
