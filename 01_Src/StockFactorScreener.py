# encoding: utf-8

# Copyright (c) Ivan Antunović (ivantun05@gmail.com) - All rights reserved.
# Unintended redistribution can be punishable by law.
# By reading this message, you are automatically consenting to it
# and you are accepting that the financial data might be incorrect.
# The financial data generated by this script is for informational purposes only
# and should not be considered as investment advice.
# Use at your own risk.


# Standard Python Modules
import datetime
import os
import json
import logging
import logging.config
from dataclasses import dataclass    # Data Class
from concurrent.futures import ThreadPoolExecutor, as_completed

# Time and Date Modules
import time
from datetime import datetime        # Manipulating dates and times

# Data Manipulation Modules
import pandas as pd

# MS Excel Moduels
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows

# Finance Metrics Modules
import yfinance as yf                # CHANGELOG: https://github.com/ranaroussi/yfinance/blob/main/CHANGELOG.rst

# Local Modules
from QualityMetrics import ProfitabilityMetrics, GrowthMetrics, SafetyMetrics
from ValueMetrics import (
    ValueMetrics,
    calc_ebit_to_tev,
    get_market_cap

)
from Stock import Stock
import ProfitabilityCalculator as profitabilityCalc
from StockDataTemplate import STOCK_DATA_TEMPLATE, INVALID_TICKER_TEMPLATE
from ZScoreCalculator import (
    calc_value_z_scores,
    calc_profitability_z_scores,
    calc_growth_z_scores,
)

from EarningsEngine import (
    calc_evar,
    calc_earnings_growth,
    get_earnings
)



# ---------------------- Script Configuration ----------------------


# Create truly immutable Python object - values of members are immutable.
# By passing 'frozen=True' to the 'dataclass()' decorator you can emulate immutability.

@dataclass(frozen=True)
class __ProgramInfo__:
    """Class for keeping track of the Program relevant information (SW-Version, Program Description, etc)."""
    
    # MAJOR: Incremented when incompatible API changes are made. Applications and other software that use the affected APIs will break.
    #        Hence, their code have to be updated.
    majorVersion : str = "0"

    # MINOR: Incremented when new functionality is added in a backward compatible manner. It's safe to update to a new minor version
    #        without requiring code changes. Code changes are needed only to make use of the new features.
    minorVersion : str = "5"
    
    # PATCH: Incremented when backward compatible bug fixes are made. No new features are added. Some call this micro.
    patchVersion : str = "6"
    
    # Build Date of the Application - Date Format: YYMMDD
    buildDate = datetime (
        year=2025,
        month=7,
        day=4
    )

    # Complete Software Version - Major.Minor.Patch.BuildDate (yymmdd) -> e.g '1.0.0'
    swVersion: str = f"{majorVersion}.{minorVersion}.{patchVersion}"


# ---------------------- Constants ----------------------

CPU_COUNT = os.cpu_count() or 1
MAX_WORKERS = max (1, CPU_COUNT - 1)


# ---------------------- Setup logging ----------------------

SCRIPT_NAME = os.path.basename(__file__).replace('.py', '')

SCRIPT_CONFIG_FILE = "ScreenerConfig.json"

LOG_FILE = f"{SCRIPT_NAME}.log"
LOG_CONFIG_FILE = "LoggingConfig.json"


def config_logging ( ):
    """ Configure the logger

            Parameters:
                None

            Returns:
                o_log_file_path (str): Path to the current Log File

    """
    o_log_file_path = LOG_FILE


    # Load Logging configuration
    with open(LOG_CONFIG_FILE, "r", encoding='utf-8') as logging_config_file:

        logging_config = json.load(logging_config_file)

        # Update the log file name dynamically
        if 'handlers' in logging_config and 'file' in logging_config['handlers']:
            logging_config['handlers']['file']['filename'] = o_log_file_path
        else:
            raise KeyError("The logging configuration JSON is missing the 'file' handler.")

        # Takes the logging configuration from a dictionary.
        logging.config.dictConfig ( logging_config )


    # Return the currently used Log File Path
    return o_log_file_path


# ---------------------- Helper Functions ----------------------

# Output the disclaimer message at the beginning of the script run
def print_disclaimer():
    disclaimer_message = """
    Copyright (c) Ivan Antunović (ivantun05@gmail.com) - All rights reserved.
    Unintended redistribution can be punishable by law.
    By reading this message, you are automatically consenting to it 
    and you are accepting that the financial data might be incorrect.
    The financial data generated by this script is for informational purposes only 
    and should not be considered as investment advice.
    Use at your own risk.
    """
    logging.info(disclaimer_message)



# Read the configuration file
def load_config (config_file='ScreenerConfig.json'):
    try:
        with open(config_file, 'r') as f:
            config = json.load(f)
        return config
    except Exception as ex:
        logging.error(f"Error loading config file!")
        logging.exception(ex)
        return None



def is_valid_ticker (symbol: str) -> bool:
    """
    Check if a stock ticker symbol is valid by attempting to fetch its latest data.

    Parameters:
        - symbol (str): The stock ticker symbol to validate.

    Returns:
        - bool: True if the ticker is valid, False otherwise.
    """
    try:

        last_price = yf.Ticker(symbol).fast_info["last_price"]

        if last_price:
            return True
        else:
            return False

    except KeyError:          # invalid tickers raise KeyError
        return False
    except Exception:
        return False



def get_ebit_to_tev (stock, ticker):
    """
    Calculate EBIT (Earnings Before Interest and Taxes) to Total Enterprise Value (TEV) ratio.

    Formula:
        EBIT / TEV = EBIT (Operating Income) / (Market Cap + Total Debt - Cash and Cash Equivalents)

    Parameters:
        - stock (yf.Ticker): A yfinance Ticker object representing the stock.
        - ticker (str): The stock ticker symbol.
        - config (dict): A dictionary containing the configuration settings.
        - quarters (int): The number of quarters to calculate EBIT for. Default is 4.

    Returns:
        - float: EBIT/TEV ratio
    """

    ebit_to_tev_ratio, enterprise_value = None, None

    try:

        ebit_to_tev_ratio, enterprise_value = calc_ebit_to_tev ( stock, ticker )

    # Catch any general exceptions
    except Exception as ex:

        logging.error(f"Error while calculating EBIT/TEV ratio (Ticker: {ticker}): {ex}")
        # Just log the exception message without the stack trace
        # This is useful for debugging purposes, but can be removed in production code
        # If you want to log the stack trace, you can use logging.exception(ex)
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            logging.exception(ex)
        return None, None

    return ebit_to_tev_ratio, enterprise_value



def calc_profitability_growth (ticker, earnings_eps, gpoa_list, roe_list, roa_list, cfoa_list, gpmar_list):

    growthMetrics = None

    try:

        logging.debug(f"Calculating Compound Annual Growth Rates (CAGR) (Ticker: {ticker}).")

        # Calculate the Compound Annual Growth Rate (CAGR) for each profitability metric

        # Calculate CAGR for EPS (Earnings Per Share)
        eps_cagr = profitabilityCalc.calc_cagr(ticker, earnings_eps)


        # Calculate CAGR for GPOA (Gross Profit over Assets)
        gpoa_cagr = profitabilityCalc.calc_cagr(ticker, gpoa_list)


        # Calculate CAGR for ROE (Return on Equity)
        roe_cagr = profitabilityCalc.calc_cagr(ticker, roe_list)


        # Calculate CAGR for ROA (Return on Assets)
        roa_cagr = profitabilityCalc.calc_cagr(ticker, roa_list)


        # Calculate CAGR for CFOA (Cash Flow Over Assets)
        cfoa_cagr = profitabilityCalc.calc_cagr(ticker, cfoa_list)


        # Calculate CAGR for GPMAR (Gross Profit Margin)
        gpmar_cagr = profitabilityCalc.calc_cagr(ticker, gpmar_list)


        growthMetrics = GrowthMetrics (
            eps_cagr,
            gpoa_cagr,
            roe_cagr,
            roa_cagr,
            cfoa_cagr,
            gpmar_cagr
        )

    except Exception as exc:
        logging.error(f"Error calculating profitability growth metrics for {ticker}: {exc}")
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            logging.exception(exc)
        growthMetrics = None

    return growthMetrics



# Function to generate excel file name
def generate_file_name(config):

    # Save the file to the 'gen' directory
    # If the directory does not exist, create it
    # The file name shall be using relative path,
    # relative to the Script's directory

    GEN_DIR_NAME = "gen"

    # Check if the 'gen' directory exists (relative to the Script's directory)
    if not os.path.exists(GEN_DIR_NAME):
        os.makedirs(GEN_DIR_NAME)

    # Get the base name of the file from the configuration
    FILE_BASE_NAME = config['Output_Excel_Filename']

    # Get the current date
    date_str = datetime.now().strftime("%Y-%m-%d")

    # Generate the final file name using the gen directory, and the date
    file_name_final = f"{GEN_DIR_NAME}\\{date_str}_{FILE_BASE_NAME}.xlsx"

    # Check if the file already exists, and increment the filename if it does
    file_counter = 1
    while os.path.exists(file_name_final):
        file_name_final = f"{GEN_DIR_NAME}\\{date_str}_{FILE_BASE_NAME}_{file_counter}.xlsx"
        file_counter += 1

    return file_name_final



# Function to save data to excel file
def save_to_excel (stock_data, tickers_and_weights, config):

    # Generate the file name with today's date
    file_name = generate_file_name (config)

    # Reorder stock_data to match tickers_and_weights
    ordered_stock_data = {}
    for ticker_data in tickers_and_weights:
        ticker_current = ticker_data["ticker"] if isinstance(ticker_data, dict) else ticker_data[0]
        if ticker_current in stock_data:
            ordered_stock_data[ticker_current] = stock_data[ticker_current]

    # Convert the data to a pandas DataFrame
    df = pd.DataFrame.from_dict(ordered_stock_data, orient='index')

    # Prepare the workbook
    wb = Workbook()
    worksheet = wb.active
    if worksheet is None:
        worksheet = wb.create_sheet(title="Sheet1")

    # Insert the ETF and Total Investment headers at the top
    worksheet['A1'] = "ETF"
    worksheet['B1'] = "MSCI World Momentum Index"
    worksheet['A2'] = "Total Investment"
    worksheet['B2'] = "1.000,00 €"

    # Add hyperlink to "S&P SmallCap Quality"
    worksheet['B1'].hyperlink = "https://www.ishares.com/uk/individual/en/products/270051/ishares-msci-world-momentum-factor-ucits-etf?switchLocale=y&siteEntryPassthrough=true"

    # Set column widths for better formatting
    worksheet.column_dimensions['A'].width = 20
    worksheet.column_dimensions['B'].width = 30

    # Append the DataFrame to the Excel worksheet
    for r_idx, row in enumerate(dataframe_to_rows(df, index=True, header=True), 4):
        worksheet.append(row)

    # Save the data to the Excel file
    df.to_excel(file_name)

    # Show the first few rows of the DataFrame
    df.head()



def calc_value_metrics (stock, ticker):

        # -------------- P/E Ratio --------------

        # fetch Forward P/E ratio
        forwardPE = stock.info.get("forwardPE", None)
        forwardPE_rnd = round(forwardPE, 2) if forwardPE is not None else "N/A"
        logging.info(f"P/E (Forward) (Ticker: {ticker}): {forwardPE_rnd}")

        # fetch Trailing P/E ratio
        trailingPE = stock.info.get("trailingPE", None)
        trailingPE_rnd = "N/A" if trailingPE in (None, 'Infinity') else round(float(trailingPE), 2)

        logging.info(f"P/E (Trailing) (Ticker: {ticker}): {trailingPE_rnd}")


        # -------------- EBIT/TEV Ratio --------------

        ebit_to_tev, enterprise_value = get_ebit_to_tev (stock, ticker)
        ebit_to_tev_perc = round(ebit_to_tev * 100, 2) if ebit_to_tev is not None else None
        if ebit_to_tev_perc is not None:
            logging.info(f"EBIT/TEV (Ticker: {ticker}): {ebit_to_tev_perc} %")
        else:
            logging.info(f"EBIT/TEV (Ticker: {ticker}): N/A")

        # -------------- P/B Ratio --------------

        # fetch P/B ratio
        pb_ratio = stock.info.get("priceToBook", None)
        pb_ratio_rnd = round(pb_ratio, 2) if pb_ratio is not None else None
        logging.info(f"P/B (Ticker: {ticker}): {pb_ratio_rnd}")

        # -------------- Value Metrics Data --------------

        value_metrics = ValueMetrics (
            ticker,
            trailingPE,
            forwardPE,
            ebit_to_tev,                # EBIT/TEV ratio
            enterprise_value,            # Total Enterprise Value (TEV)
            pb_ratio                    # P/B ratio
        )

        return value_metrics



def analyze_stock (config, stock, ticker, weight):

    try:

        logging.info(f"---------------------- {ticker} ----------------------")

        ########################################################
        ###################   VALUE METRICS   ##################
        ########################################################

        value_metrics = None
        value_metrics = calc_value_metrics (
            stock,
            ticker
        )

        ########################################################
        ###############   PROFITABILITY METRICS   ##############
        ########################################################

        # -------------- 1. Get Earnings (EPS) Data --------------

        # 1.1 Get EPS data
        earnings_eps = get_earnings (
            stock,
            ticker,
            "eps",
            config['Earnings_Period'],
            config['AlphaVantage']['API_Key'],
            config['AlphaVantage']['Base_URL'],
        )

        eps_latest_rnd = round (earnings_eps[0], 2) if earnings_eps is not None else None
        if earnings_eps:
            logging.info(f"Fetched Earnings data (EPS) for {len(earnings_eps)} years period (Ticker: {ticker}).")
            logging.info(f"EPS (latest) (Ticker: {ticker}): {(eps_latest_rnd)}")

        # 1.2 Calculate EPS Growth Year-on-Year (YoY) for each year
        earnings_growths_eps = calc_earnings_growth (
            ticker,
            earnings_eps
        )

        # -------------- 2. Get Earnings (Net Income) Data --------------

        earnings_net_income = None
        try:
            # 2.1 Get Net Income data
            earnings_net_income = profitabilityCalc.get_earnings (
                stock,
                ticker,
                "net_income",
                config['Earnings_Period'],
                config['AlphaVantage']['API_Key'], 
                config['AlphaVantage']['Base_URL'], 
            )

            if earnings_net_income:
                logging.info(f"Fetched Earnings data (Net Income) for {len(earnings_net_income)} years period (Ticker: {ticker}).")
        
        except Exception as exc:
            logging.error(f"Error fetching Earnings data (Net Income) for {ticker}: {exc}")
            earnings_net_income = None

        # 2.2 Calculate Net Income Growth Year-on-Year (YoY) for each year
        earnings_growths_net_income = calc_earnings_growth (
            ticker,
            earnings_net_income
        )

        # -------------- Calculate Earnings Variability (EVAR) --------------

        # Calculate Earnings Variability Earnings Variability is defined as
        # the standard deviation of y-o-y earnings per share growth over the last five fiscal years.
        # The lower the EVAR, the better. A lower EVAR indicates that the company has more stable earnings growth.

        evar_eps, evar_eps_perc = None, None
        try:

            if earnings_growths_eps:
                logging.info(f"Calculating Earnings Variability (EVAR) using EPS over {len(earnings_growths_eps)} year period (Ticker: {ticker}).")
                # Calculate EVAR using EPS
                evar_eps = calc_evar (ticker, earnings_growths_eps)
                evar_eps_perc = round(evar_eps * 100, 2) if evar_eps is not None else "N/A"

                if earnings_eps is not None:
                    logging.info(f"EVAR {len(earnings_eps)}Y (EPS) (Ticker: {ticker}): {(evar_eps_perc)}%")
                else:
                    logging.info(f"EVAR (EPS) (Ticker: {ticker}): N/A")

            else:
                logging.error(f"Cannot calculate EVAR (EPS) for {ticker}. No Earnings Growth data available.")
                evar_eps = None
                evar_eps_perc = "N/A"

        except Exception as evar_error:
            logging.error(f"Error calculating EVAR (Ticker: {ticker}): {evar_error}")
            evar_eps = None
            evar_eps_perc = "N/A"

        evar_net_income, evar_net_income_perc = None, None
        try:
            if earnings_growths_net_income:
                logging.info(f"Calculating Earnings Variability (EVAR) using Net Income over {len(earnings_growths_net_income)} year period (Ticker: {ticker}).")
                # Calculate EVAR using Net Income
                evar_net_income = calc_evar (ticker, earnings_growths_net_income)
                evar_net_income_perc = round(evar_net_income * 100, 2) if evar_net_income is not None else "N/A"
                if earnings_net_income is not None:
                    logging.info(f"EVAR {len(earnings_net_income)}Y (Net Income) (Ticker: {ticker}): {(evar_net_income_perc)}%")
                else:
                    logging.info(f"EVAR (Net Income) (Ticker: {ticker}): N/A")

            else:
                logging.error(f"Cannot calculate EVAR (Net Income) for {ticker}. No Earnings Growth data available.")
                evar_net_income = None
                evar_net_income_perc = "N/A"

        except Exception as evar_error:
            logging.error(f"Error calculating EVAR (Ticker: {ticker}): {evar_error}")
            evar_net_income = None
            evar_net_income_perc = "N/A"

        # -------------- Compound Annual Growth Rate (CAGR) --------------

        cagr_eps = profitabilityCalc.calc_cagr (ticker, earnings_eps)
        cagr_eps_perc = round(cagr_eps * 100, 2) if cagr_eps is not None else None
        if cagr_eps_perc is not None:
            logging.info(f"CAGR {len(earnings_eps)}Y (EPS) (Ticker: {ticker}): {cagr_eps_perc} %")
        else:
            logging.info(f"CAGR (EPS) (Ticker: {ticker}): N/A")

        cagr_net_income = profitabilityCalc.calc_cagr(ticker, earnings_net_income)
        cagr_net_income_perc = round(cagr_net_income * 100, 2) if cagr_net_income is not None else None
        if cagr_net_income is not None:
            logging.info(f"CAGR {len(earnings_net_income)}Y (Net Income) (Ticker: {ticker}): {cagr_net_income_perc} %")
        else:
            logging.info(f"CAGR (Net Income) (Ticker: {ticker}): N/A")

        # -------------- Dividend Yield Fetched Data --------------

        # Safe multiplication to handle None values, Convert to percentage
        dividend_yield = stock.info.get("dividendYield", None)

        if dividend_yield:
            logging.info(f"Dividend Yield (Ticker: {ticker}): {round(dividend_yield, 2)} %")
        else:
            logging.info(f"Dividend Yield (Ticker: {ticker}): N/A")

        # -------------- Return on Equity (ROE) --------------

        # TODO: TTM - Most factor datasets (e.g., AQR DS, Alpha Research Platform) choose “closest past match” so that both numerator and denominator
        # are built only from information that was public at, or before, that quarter-end.

        # Fetch ROE using Yahoo Finance data
        roe_ttm_yf = profitabilityCalc.get_roe_ttm (stock.info)
        # Convert ROE to percentage
        roe_ttm_yf_perc = roe_ttm_yf * 100 if roe_ttm_yf is not None else None
        if roe_ttm_yf_perc is not None:
            logging.info(f"ROE (ttm) (Yahoo Finance) (Ticker: {ticker}): {round(roe_ttm_yf_perc, 2)} %")
        else:
            logging.info(f"ROE (ttm) (Yahoo Finance) (Ticker: {ticker}): N/A")


        roe_list = None
        try:
            # Calculate ROE using Net Income and Shareholder's Equity 
            roe_list = profitabilityCalc.calc_roe (stock, ticker, config, config.get("Earnings_Period"))

        except profitabilityCalc.ROECalcError as roe_error:
            logging.error(f"Error calculating ROE (Ticker: {ticker}): {roe_error}")
            roe_list = None


        roe_ttm = None
        roe_calc_perc = None
        try:
            # Get the TTM ROE
            roe_ttm = profitabilityCalc.calc_roe_ttm ( stock, ticker )

            # Convert ROE to percentage
            roe_calc_perc = roe_ttm * 100 if roe_ttm is not None else None
            if roe_ttm_yf_perc is not None and roe_calc_perc is not None:
                logging.info("ROE - Calc (Ticker: %s): %.2f %%", ticker, round(roe_calc_perc, 2))
            else:
                logging.info("ROE - Calc (Ticker: %s): N/A", ticker)

        except profitabilityCalc.ROECalcError as roe_error:
            logging.error(f"Error calculating ROE (ttm) (Ticker: {ticker}): {roe_error}")
            roe_ttm = None


        roe_msci = profitabilityCalc.calc_roe_msci (stock, ticker)
        roe_msci_perc = roe_msci * 100 if roe_msci is not None else None
        if roe_msci_perc is not None:
            logging.info(f"ROE - MSCI (Ticker: {ticker}): {round(roe_msci_perc, 2)} %")
        else:
            logging.info(f"ROE - MSCI (Ticker: {ticker}): N/A")




        # TODO: calc_roe function - if the net income data from yahoo finance is missing
        #       then avoid using Stockholders Equity data from yahoo finance to calcualte ROE
        #       else the ROE might be calculated with the mismatching data.
        #       For example, Net Income from 2023 and Stockholders Equity from 2022.
        #       Such mismatching data can lead to incorrect ROE calculations.

        # TODO: Calculate ROE and ROA over multiple time periods
        #       Compare the logs before and after, and validate the calculations

        # TODO: Verify that CAGR calculations are correct for all stocks using https://finchat.io/dashboard/

        # TODO: Parallize the calculations of stock finacial metrics

        # TODO Calculcate ROE using EPS

        # TODO: Check the missing Net Income data for ROE calculcation for INVX
        # TODO: Validate Standard Deviation Calucations for all stocks


        # -------------- Return on Assets (ROA) --------------

        # Fetch ROA using Yahoo Finance data
        roa_ttm_yf = profitabilityCalc.get_roa_ttm (stock.info)
        # Convert ROA to percentage
        roa_ttm_yf_perc = roa_ttm_yf * 100 if roa_ttm_yf is not None else None
        if roa_ttm_yf_perc is not None:
            logging.info(f"ROA (ttm) (Yahoo Finance) (Ticker: {ticker}): {round(roa_ttm_yf_perc, 2)} %")
        else:
            logging.info(f"ROA (ttm) (Yahoo Finance) (Ticker: {ticker}): N/A")


        roa_list, roa_calc_perc = None, None
        try:
            # Calculate ROA using Net Income and Total Assets
            roa_list = profitabilityCalc.calc_roa (stock, ticker, config)

            if roa_list is not None:
                # Convert ROA to percentage
                roa_calc_perc = roa_list[0] * 100 if roa_list[0] is not None else None
                if roa_calc_perc is not None:
                    logging.info("ROA - Calc (Ticker: %s): %.2f %%", ticker, round(roa_calc_perc, 2))
                else:
                    logging.info("ROA - Calc (Ticker: %s): N/A", ticker)
            else:
                logging.error(f"Cannot calculate ROA (Ticker: {ticker}): ROA list is empty")
                roa_calc_perc = None
    
        except profitabilityCalc.ROACalcError as roa_error:
            logging.error(f"Error calculating ROA (Ticker: {ticker}): {roa_error}")
            roa_list = None
            roa_calc_perc = None


        # -------------- Cash Flow Over Assets (CFOA) --------------
        cfoa_list, cfoa_latest_perc = None, None
        try:
            cfoa_list = profitabilityCalc.calc_cfoa (stock, ticker)
            cfoa_latest_perc = round(cfoa_list[0] * 100, 2) if cfoa_list is not None else None
            logging.info(f"CFOA (annual) (Ticker: {ticker}): {cfoa_latest_perc} %")

        except profitabilityCalc.CFOACalcError as cfoa_error:
            logging.error(f"Error calculating CFOA (annual) (Ticker: {ticker}): {cfoa_error}")
            cfoa_list = None
            cfoa_latest_perc = None

        # Calculate CFOA TTM
        cfoa_ttm, cfoa_ttm_perc = None, None
        try:
            cfoa_ttm = profitabilityCalc.calc_cfoa_ttm (stock, ticker)
            cfoa_ttm_perc = round(cfoa_ttm * 100, 2) if cfoa_ttm is not None else None
            logging.info(f"CFOA (ttm) (Ticker: {ticker}): {cfoa_ttm_perc} %")

        except profitabilityCalc.CFOACalcError as cfoa_error:
            logging.error(f"Error calculating CFOA (ttm) (Ticker: {ticker}): {cfoa_error}")
            cfoa_ttm = None
            cfoa_ttm_perc = None


        # --------------   Gross Profits Over Assets (GPOA)
        #                & Gross Profit Margin (GPMAR)  --------------
 
        # TODO: Check the the GPOA is not N/A for the following stocks:
        #       ECG, AX, RDN

        gpoa_list, gpmar_list, gpoa_latest_perc, gpmar_latest_perc = None, None, None, None
        try:

            gpoa_list, gpmar_list = profitabilityCalc.calc_gross_profit_metrics (config, stock, ticker, config.get("Earnings_Period"))

            gpoa_latest_perc = round(gpoa_list[0] * 100, 2) if gpoa_list is not None else None
            logging.info(f"GPOA (Ticker: {ticker}): {gpoa_latest_perc} %")

            gpmar_latest_perc = round(gpmar_list[0] * 100, 2) if gpmar_list is not None else None
            logging.info(f"GPMAR (Ticker: {ticker}): {gpmar_latest_perc} %")

        except profitabilityCalc.GPOACalcError as gpoa_error:
            logging.error(f"Error calculating GPOA and GPMAR (Ticker: {ticker}): {gpoa_error}")
            gpoa_list = None
            gpmar_list = None
            gpoa_latest_perc = None
            gpmar_latest_perc = None


        gpoa_ttm_perc, gpmar_ttm_perc, gpmar_ttm, gpoa_ttm = None, None, None, None
        try:

            # Calculate GPOA
            gpoa_ttm = profitabilityCalc.calc_gpoa_ttm ( stock, ticker )
            # Convert GPOA to percentage
            gpoa_ttm_perc = round(gpoa_ttm * 100, 2) if gpoa_ttm is not None else None

            # Calculate GPMAR
            gpmar_ttm =  profitabilityCalc.calc_gpmar_ttm ( stock, ticker )
            # Convert GPMAR to percentage
            gpmar_ttm_perc = round(gpmar_ttm * 100, 2) if gpmar_ttm is not None else None

        except profitabilityCalc.GPOACalcError as gpoa_error:
            logging.error(f"Error calculating GPOA and GPMAR TTM (Ticker: {ticker}): {gpoa_error}")
            gpoa_ttm = None

        except profitabilityCalc.GPMARCalcError as gpmar_error:
            logging.error(f"Error calculating GPMAR TTM (Ticker: {ticker}): {gpmar_error}")
            gpmar_ttm = None

        # -------------- Profit Margin --------------
        # Safe multiplication to handle None values, Convert to percentage
        profit_margin = stock.info.get("profitMargins", None)
        profit_margin_percent = profit_margin * 100 if profit_margin is not None else None
        if profit_margin_percent is not None:
            logging.info(f"Profit Margin (Ticker: {ticker}): {round(profit_margin_percent, 2)} %")
        else:
            logging.info(f"Profit Margin (Ticker: {ticker}): N/A")


        # -------------- Market Cap --------------
        # Convert Market Cap to billions
        market_cap = get_market_cap(stock)
        market_cap_bill = round(market_cap / 1e9, 2) if market_cap is not None else "N/A"  # Convert Market Cap to billions


        # -------------- Sector and Industry --------------

        # Extract the industry and sector
        sector = stock.info.get("sector", "N/A")
        industry = stock.info.get("industry", "N/A")

        logging.info(f"Sector: {sector}")
        logging.info(f"Industry: {industry}")

        # TODO: Calculate Pie Chart of Sectors diversification
        #       for the calculcated weightings using your own qualit methodology
        #       We want to be diviersified across sectors.
        #       Diversification is the only free lunch in investing.


        # TODO: Calculate all Profitability Metrics using TTM data, and not latest year data

        # -------------- Profitability Metrics --------------
        profitability_metrics = ProfitabilityMetrics (
            ticker,
            earnings_growths_eps,      # EPS Growth last year
            evar_eps,                  # EPS Variability last year
            gpoa_ttm,                  # Gross Profit over Assets (GPOA) TTM
            gpmar_ttm,                 # Gross Profit Margin (GPMAR) TTM
            roe_ttm_yf,                # Return on Equity (ROE) TTM
            roa_ttm_yf,                # Return on Assets (ROA) TTM
            cfoa_list,                 # Cash Flow over Assets (CFOA) last year
            None                       # Accruals None
        )


        # --------------  Profitability Growth Metrics --------------
        # earnings_growths_eps
        # gpoa_growth
        # roe_growth      
        # roa_growth  
        # cfoa_growth
        # gpmar_growth
        profitability_growth_metrics = calc_profitability_growth (
            ticker,
            earnings_eps,                 # Five-year growth in Earnings per Share (EPS) - EPS Growth
            gpoa_list,                    # Five-year growth in Gross Profits over Assets - GPOA Growth
            roe_list,                     # Five-year growth in Return on Equity - ROE Growth
            roa_list,                     # Five-year growth in Return on Assets - ROA Growth
            cfoa_list,                    # Five-year growth in Cash Flow over Assets - CFOA Growth
            gpmar_list                    # Five-year growth in Gross Profit Margin - GPMAR Growth
        )

        # -------------- Store Stock Metrics --------------

        stock_factor_metrics = Stock (
            ticker,
            sector,
            value_metrics,
            profitability_metrics,
            profitability_growth_metrics,
            None
        )

        # Build Stock Data Dictionary
        stock_data = STOCK_DATA_TEMPLATE.copy()
        stock_data.update({
            "Company": stock.info.get("longName", "N/A"),
            "Original Weight": weight,  # Add the original weight for the company
            "Market Cap (in Billions)": market_cap_bill,
            "P/E (Forward)": '{:,.2f}'.format(value_metrics.pe_forward) if value_metrics.pe_forward is not None else "N/A",
            "P/E (Trailing)":  '{:,.2f}'.format(value_metrics.pe_trailing) if value_metrics.pe_trailing is not None else "N/A",
            "EBIT/TEV (%)": '{:,.2f}'.format(round(value_metrics.ebit_to_tev * 100, 2)) if value_metrics.ebit_to_tev is not None else "N/A",
            "TEV (in Billions)": '{:,.2f}'.format(round(value_metrics.enterprise_value_bill, 2)) if value_metrics.enterprise_value_bill is not None else "N/A",
            "P/B": '{:,.2f}'.format(round(value_metrics.pb_ratio, 2)) if value_metrics.pb_ratio is not None else "N/A",
            "EPS (latest)": '{:,.2f}'.format(eps_latest_rnd) if eps_latest_rnd is not None else "N/A",
            "EVAR - EPS (%)":"{}".format(evar_eps_perc),
            "EVAR - Net Income (%)":"{}".format(evar_net_income_perc),
            "CAGR - EPS (%)": '{:,.2f}'.format(cagr_eps_perc) if cagr_eps_perc is not None else "N/A",
            "CAGR - Net Income (%)": '{:,.2f}'.format(cagr_net_income_perc) if cagr_net_income_perc is not None else "N/A",
            "Dividend Yield (%)": '{:,.2f}'.format(dividend_yield) if dividend_yield is not None else "N/A",     
            "ROE (ttm) - yFinance (%)": '{:,.2f}'.format(roe_ttm_yf_perc) if roe_ttm_yf_perc is not None else "N/A",
            "ROE (ttm) - Calc (%)": '{:,.2f}'.format(roe_calc_perc) if roe_calc_perc is not None else "N/A",
            "ROA - yFinance (%)": '{:,.2f}'.format(roa_ttm_yf_perc) if roa_ttm_yf_perc is not None else "N/A",
            "ROA - Calc (%)": '{:,.2f}'.format(roa_calc_perc) if roa_calc_perc is not None else "N/A",
            "CFOA (annual) (%)": '{:,.2f}'.format(cfoa_latest_perc) if cfoa_latest_perc is not None else "N/A",
            "CFOA (ttm) (%)": '{:,.2f}'.format(cfoa_ttm_perc) if cfoa_ttm_perc is not None else "N/A",
            "GPOA (ttm) (%)": '{:,.2f}'.format(gpoa_ttm_perc) if gpoa_ttm_perc is not None else "N/A",
            "GPMAR (ttm) (%)": '{:,.2f}'.format(gpmar_ttm_perc) if gpmar_ttm_perc is not None else "N/A",
            "Profit Margin (%)": '{:,.2f}'.format(profit_margin_percent) if profit_margin_percent is not None else "N/A",
            "Sector": sector,
            "Industry": industry
        })

        # Return the stock data and metrics
        return stock_data, stock_factor_metrics

    except Exception as e:
        logging.error("Unhandled error analyzing stock (Ticker: %s)", ticker)
        logging.exception(e)
        return None, None



def analyze_one_stock (ticker_data, i_config):

    # Get the ticker and weight
    ticker = ticker_data["ticker"]
    weight = ticker_data["weight"]

    try:

        # Fetch the stock data from Yahoo Finance
        stock = yf.Ticker(ticker)

        # Get stock data
        stock_info = stock.info

        # Check if the stock info is available and contains the 'symbol' key
        # and if the ticker symbol is valid
        if stock_info and 'symbol' in stock_info and is_valid_ticker(ticker):

            # If the ticker symbol is valid, analyze the stock
            stock_data_entry, stock_factor_metrics = analyze_stock (
                i_config,
                stock,
                ticker,
                weight
            )

            return ticker, stock_data_entry, stock_factor_metrics

        else:
            # If the ticker symbol is invalid, log the error and return an invalid entry
            # Log the error and return an invalid entry
            logging.error(f"Invalid Stock Ticker Symbol: {ticker}")
            logging.error(f"Skipping Stock Analysis for {ticker}.")
            invalid_entry = INVALID_TICKER_TEMPLATE.copy()
            invalid_entry["Company"] = ticker
            invalid_entry["Original Weight"] = weight

            return ticker, invalid_entry, None
        
    except Exception as e:
        # Log the error and return an invalid entry
        logging.critical(f"Error analyzing stock (Ticker: {ticker}): {e}!")
        logging.exception(e)
        invalid_entry = INVALID_TICKER_TEMPLATE.copy()
        invalid_entry["Company"] = ticker
        invalid_entry["Original Weight"] = weight

        return ticker, invalid_entry, None



# ---------------------- Main Function ----------------------

# Example usage in the script
if __name__ == "__main__":

    current_ticker = None

    try:

        # -------------------------------- 1. Initialize the Script -------------------------------- #

        # Store Script Start Date
        programStartDate = time.strftime ('%Y-%m-%d %H:%M:%S', time.localtime())

        # Store Scripts Start Time
        programStartTime = datetime.now ( )

        log_file_path = config_logging()

        # Instantiate Program Information Object
        __program__ = __ProgramInfo__ ( )

        # Print the Script Date (Format YYYY-MM-DD) and Version
        logging.info(f"Running Stock Analysis Script:\n    Version: {__program__.swVersion}\n    Date: {__program__.buildDate.strftime('%d.%m.%Y')}")

        # Print the disclaimer message
        print_disclaimer()

        # Load the configuration file
        config = load_config(SCRIPT_CONFIG_FILE)
        if not config:
            logging.error("Config file could not be loaded. Exiting script.")
            exit()

        # Get the tickers and weights from the config file
        tickers_and_weights = config.get("Tickers_and_Weights", None)

        # Fetch data using yfinance and include original weights
        stock_data = {}

        # Initialize the list of stock metrics, there metrics for each stock will be stored
        stock_factor_metrics_list = []

        # Enable Debug Mode for yfinance
        #yf.enable_debug_mode()

        # Get the yfinance logger
        yf_logger = logging.getLogger("yfinance")
        yf_logger.disabled = True
        yf_logger.propagate = False

        # Loop through the tickers and weights
        with ThreadPoolExecutor (max_workers=MAX_WORKERS) as executor:

            futures = [ executor.submit ( analyze_one_stock, ticker_data, config ) for ticker_data in tickers_and_weights ]

            for future in as_completed (futures):
                ticker, stock_data_entry, stock_factor_metrics = future.result()
                current_ticker = ticker  # Track the most recently processed ticker globally
                if stock_data_entry:
                    stock_data[ticker] = stock_data_entry
                if stock_factor_metrics:
                    stock_factor_metrics_list.append(stock_factor_metrics)

        # Step 2: Calculate Z-scores for All Stocks (Normalize after gathering data)
        #calculate_z_scores(stock_data)
        # Calculate z-score for Value Metrics

        # 1. Gather Metrics for All Stocks:
        #   - Collect the relevant metrics (Value metrics, Profitability metrics, and Growth metrics) for each stock. This happens first, and we store them in a stock_data dictionary.

        # 2. Once All Stocks Are Analyzed:
        #   - Once we’ve collected the data for all stocks, normalize the metrics by calculating Z-scores for each metric across all stocks.
        #   - Calculate Z-scores for each of the three categories (Value, Profitability, and Growth) for all the stocks at the end, ensuring they are normalized across the entire group of stocks.

        value_cfg = config.get("ValueFactor", None)
        profitability_cfg = config.get("ProfitabilityFactor", None)
        growth_cfg = config.get("GrowthFactor", None)

        # Calculate Z-scores for each factor
        #value_z  = calc_value_z_scores (stock_factor_metrics_list, value_cfg)
        #profit_z = calc_profitability_z_scores (stock_factor_metrics_list, profitability_cfg)
        #growth_z = calc_growth_z_scores (stock_factor_metrics_list, growth_cfg)

        # 3. Final Z-Score Calculation:
        #   - After the Z-scores for the individual metrics are calculated, compute the final Z-score for each stock by averaging the Z-scores from all three categories.

        # 4. Output the Results:
        #   - Save the final Z-scores and all metrics in the Excel file for easy reference.


        # -------------------- Excel File Generation --------------------

        # Save the stock data to an Excel file
        save_to_excel (
            stock_data,
            tickers_and_weights,
            config
        )

        # -------------------- Program Runtime --------------------
        # Output program's runtime
        programRuntime = datetime.now() - programStartTime
        logging.info (f"Program total runtime: {programRuntime}")

    except Exception as e:
        logging.critical(f"Unhandled ERROR running the Script occurred (Ticker: {current_ticker}): {e} !")
        logging.exception(f"Unhandled exception occurred while running the script: {e}")
        raise e
    
    finally:
        logging.shutdown()
